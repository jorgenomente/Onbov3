-- =============================================
-- LOTE 0.2 — Lifecycle Base + Auditoría
-- =============================================

-- -------------------------------------------------
-- ENUMS
-- -------------------------------------------------
do $$
begin
  if not exists (select 1 from pg_type where typname = 'course_status') then
    create type public.course_status as enum ('draft', 'active', 'archived');
  end if;
end $$;

-- -------------------------------------------------
-- COURSES (ORG-SCOPED, L0.x)
-- NOTE:
-- En L0.x los cursos son scope ORGANIZACIÓN.
-- La asignación a locales se implementa en L1.x
-- vía tabla local_courses.
-- -------------------------------------------------
create table if not exists public.courses (
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null references public.organizations(id) on delete restrict,
  status public.course_status not null default 'draft',
  created_at timestamptz not null default now()
);

create index if not exists courses_org_id_idx on public.courses(org_id);
create index if not exists courses_status_idx on public.courses(status);

alter table public.courses enable row level security;

-- -------------------------------------------------
-- AUDIT LOGS (APPEND-ONLY)
-- -------------------------------------------------
create table if not exists public.audit_logs (
  id bigint generated by default as identity primary key,
  actor_id uuid not null references public.profiles(id) on delete restrict,
  org_id uuid not null references public.organizations(id) on delete restrict,
  local_id uuid references public.locales(id) on delete restrict,
  entity_type text not null,
  entity_id uuid,
  action text not null,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now()
);

create index if not exists audit_logs_org_id_idx on public.audit_logs(org_id);
create index if not exists audit_logs_actor_id_idx on public.audit_logs(actor_id);
create index if not exists audit_logs_entity_idx on public.audit_logs(entity_type, entity_id);
create index if not exists audit_logs_created_at_idx on public.audit_logs(created_at);

alter table public.audit_logs enable row level security;

-- -------------------------------------------------
-- RLS POLICIES — COURSES
-- -------------------------------------------------
drop policy if exists courses_superadmin_all on public.courses;
drop policy if exists courses_org_admin_select on public.courses;

create policy courses_superadmin_all
on public.courses
for all
using (public.is_superadmin())
with check (public.is_superadmin());

create policy courses_org_admin_select
on public.courses
for select
using (
  public.has_role('org_admin'::public.profile_role)
  and org_id = public.current_org_id()
);

-- -------------------------------------------------
-- RLS POLICIES — AUDIT LOGS
-- -------------------------------------------------
drop policy if exists audit_logs_superadmin_select on public.audit_logs;
drop policy if exists audit_logs_org_admin_select on public.audit_logs;
drop policy if exists audit_logs_referente_select on public.audit_logs;

create policy audit_logs_superadmin_select
on public.audit_logs
for select
using (public.is_superadmin());

create policy audit_logs_org_admin_select
on public.audit_logs
for select
using (
  public.has_role('org_admin'::public.profile_role)
  and org_id = public.current_org_id()
);

create policy audit_logs_referente_select
on public.audit_logs
for select
using (
  public.has_role('referente'::public.profile_role)
  and local_id = public.current_local_id()
);

-- -------------------------------------------------
-- RPC: ARCHIVE USER
-- -------------------------------------------------
create or replace function public.archive_user(target_user_id uuid)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  actor_role public.profile_role;
  actor_status public.profile_status;
  actor_org_id uuid;
  target_org_id uuid;
  target_local_id uuid;
  target_status public.profile_status;
begin
  select role, status, org_id
    into actor_role, actor_status, actor_org_id
  from public.profiles
  where id = auth.uid();

  if actor_role is null then
    raise exception 'actor_profile_missing';
  end if;

  if actor_status = 'archived' then
    raise exception 'actor_archived';
  end if;

  if actor_role not in ('superadmin', 'org_admin') then
    raise exception 'insufficient_privilege';
  end if;

  select org_id, local_id, status
    into target_org_id, target_local_id, target_status
  from public.profiles
  where id = target_user_id;

  if target_org_id is null then
    raise exception 'target_not_found';
  end if;

  if actor_role <> 'superadmin' and target_org_id <> actor_org_id then
    raise exception 'cross_org_forbidden';
  end if;

  update public.profiles
  set status = 'archived'
  where id = target_user_id
    and org_id = target_org_id;

  insert into public.audit_logs (
    actor_id,
    org_id,
    local_id,
    entity_type,
    entity_id,
    action,
    metadata
  )
  values (
    auth.uid(),
    target_org_id,
    target_local_id,
    'profile',
    target_user_id,
    'archive_user',
    jsonb_build_object('previous_status', target_status)
  );
end;
$$;

-- -------------------------------------------------
-- RPC: REACTIVATE USER
-- -------------------------------------------------
create or replace function public.reactivate_user(target_user_id uuid)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  actor_role public.profile_role;
  actor_status public.profile_status;
  actor_org_id uuid;
  target_org_id uuid;
  target_local_id uuid;
  target_status public.profile_status;
begin
  select role, status, org_id
    into actor_role, actor_status, actor_org_id
  from public.profiles
  where id = auth.uid();

  if actor_role is null then
    raise exception 'actor_profile_missing';
  end if;

  if actor_status = 'archived' then
    raise exception 'actor_archived';
  end if;

  if actor_role not in ('superadmin', 'org_admin') then
    raise exception 'insufficient_privilege';
  end if;

  select org_id, local_id, status
    into target_org_id, target_local_id, target_status
  from public.profiles
  where id = target_user_id;

  if target_org_id is null then
    raise exception 'target_not_found';
  end if;

  if actor_role <> 'superadmin' and target_org_id <> actor_org_id then
    raise exception 'cross_org_forbidden';
  end if;

  update public.profiles
  set status = 'active'
  where id = target_user_id
    and org_id = target_org_id;

  insert into public.audit_logs (
    actor_id,
    org_id,
    local_id,
    entity_type,
    entity_id,
    action,
    metadata
  )
  values (
    auth.uid(),
    target_org_id,
    target_local_id,
    'profile',
    target_user_id,
    'reactivate_user',
    jsonb_build_object('previous_status', target_status)
  );
end;
$$;

-- -------------------------------------------------
-- RPC: TRANSFER USER LOCAL (INTRA-ORG)
-- -------------------------------------------------
create or replace function public.transfer_user_local(
  target_user_id uuid,
  new_local_id uuid
)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  actor_role public.profile_role;
  actor_status public.profile_status;
  actor_org_id uuid;
  target_org_id uuid;
  target_local_id uuid;
  new_local_org_id uuid;
begin
  select role, status, org_id
    into actor_role, actor_status, actor_org_id
  from public.profiles
  where id = auth.uid();

  if actor_role is null then
    raise exception 'actor_profile_missing';
  end if;

  if actor_status = 'archived' then
    raise exception 'actor_archived';
  end if;

  if actor_role not in ('superadmin', 'org_admin') then
    raise exception 'insufficient_privilege';
  end if;

  select org_id, local_id
    into target_org_id, target_local_id
  from public.profiles
  where id = target_user_id;

  if target_org_id is null then
    raise exception 'target_not_found';
  end if;

  select org_id
    into new_local_org_id
  from public.locales
  where id = new_local_id;

  if new_local_org_id is null then
    raise exception 'local_not_found';
  end if;

  if target_org_id <> new_local_org_id then
    raise exception 'cross_org_transfer_forbidden';
  end if;

  if actor_role <> 'superadmin' and target_org_id <> actor_org_id then
    raise exception 'cross_org_forbidden';
  end if;

  update public.profiles
  set local_id = new_local_id
  where id = target_user_id
    and org_id = target_org_id;

  insert into public.audit_logs (
    actor_id,
    org_id,
    local_id,
    entity_type,
    entity_id,
    action,
    metadata
  )
  values (
    auth.uid(),
    target_org_id,
    new_local_id,
    'profile',
    target_user_id,
    'transfer_user_local',
    jsonb_build_object(
      'from_local_id', target_local_id,
      'to_local_id', new_local_id
    )
  );
end;
$$;

-- -------------------------------------------------
-- GRANTS (LEAST PRIVILEGE)
-- -------------------------------------------------
revoke all on table public.courses from public, anon, authenticated;
revoke all on table public.audit_logs from public, anon, authenticated;

grant select on table public.courses to authenticated;
grant select on table public.audit_logs to authenticated;

revoke all on function public.archive_user(uuid) from public;
revoke all on function public.reactivate_user(uuid) from public;
revoke all on function public.transfer_user_local(uuid, uuid) from public;

grant execute on function public.archive_user(uuid) to authenticated;
grant execute on function public.reactivate_user(uuid) to authenticated;
grant execute on function public.transfer_user_local(uuid, uuid) to authenticated;

-- -------------------------------------------------
-- SMOKE TESTS (MANUAL)
-- -------------------------------------------------
-- 1) Actor archived -> cannot execute lifecycle RPCs
--    select public.archive_user('target-user-uuid');

-- 2) Referente / Aprendiz -> cannot execute lifecycle RPCs
--    select public.reactivate_user('target-user-uuid');

-- 3) Org Admin -> can archive/reactivate within org, cannot cross-org transfer
--    select public.transfer_user_local('target-user-uuid', 'other-org-local-uuid');

-- 4) Valid transfer -> local_id changes, org_id unchanged
--    select id, org_id, local_id from public.profiles where id = 'target-user-uuid';

-- 5) Audit -> each RPC inserts exactly one row with correct actor/action
--    select actor_id, entity_type, action
--    from public.audit_logs
--    where entity_id = 'target-user-uuid'
--    order by id desc limit 1;

-- 6) Referente audit scope -> only own local
--    select count(*) from public.audit_logs
--    where local_id <> public.current_local_id(); -- must be 0

-- 7) Direct UPDATE blocked
--    update public.profiles set status = 'active'; -- must fail
